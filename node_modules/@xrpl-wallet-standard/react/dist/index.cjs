"use client";
'use strict';

var jsxRuntime = require('react/jsx-runtime');
var colors = require('@radix-ui/colors');
var styled = require('styled-components');
var Dialog = require('@radix-ui/react-dialog');
var reactIcons = require('@radix-ui/react-icons');
var react = require('react');
var zustand = require('zustand');
var app = require('@xrpl-wallet-standard/app');
var middleware = require('zustand/middleware');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var Dialog__namespace = /*#__PURE__*/_interopNamespaceDefault(Dialog);

const WalletContext = react.createContext(null);

function useWalletStore(selector) {
  const store = react.useContext(WalletContext);
  if (!store)
    throw new Error(
      "useWalletStore must be used within a WalletProvider. Did you forget to wrap your component in a WalletProvider?"
    );
  return zustand.useStore(store, selector);
}

const useAccount = () => {
  return useWalletStore((state) => state.currentAccount);
};

const useAccounts = () => {
  return useWalletStore((state) => state.accounts);
};

const useConnect = () => {
  const connectionStatus = useWalletStore((state) => state.connectionStatus);
  const setConnectionStatus = useWalletStore((state) => state.setConnectionStatus);
  const setWallet = useWalletStore((state) => state.setWallet);
  const handleConnect = async (wallet, input) => {
    setConnectionStatus("connecting");
    try {
      const { accounts } = await wallet.features["standard:connect"].connect(input);
      if (accounts.length === 0) {
        throw new Error("No accounts found");
      }
      const account = accounts[0];
      setWallet(wallet, accounts, account);
      setConnectionStatus("connected");
    } catch (e) {
      setConnectionStatus("disconnected");
      throw e;
    }
  };
  return { connect: handleConnect, status: connectionStatus };
};

const useConnectionStatus = () => {
  const status = useWalletStore((state) => state.connectionStatus);
  return status;
};

const useDisconnect = () => {
  const wallet = useWalletStore((state) => state.currentWallet);
  const setWalletDisconnected = useWalletStore((state) => state.setWalletDisconnected);
  const handleDisconnect = async () => {
    if (!wallet) throw new Error("Wallet is not connected");
    if (app.isWalletWithRequiredFeatureSet(wallet, ["standard:disconnect"]))
      try {
        await wallet.features["standard:disconnect"].disconnect();
      } catch (e) {
        console.error(e);
      }
    setWalletDisconnected();
  };
  return handleDisconnect;
};

const useSignAndSubmitTransaction = () => {
  const wallet = useWalletStore((state) => state.currentWallet);
  const account = useWalletStore((state) => state.currentAccount);
  const handleSignAndSubmitTransaction = async (transaction, network) => {
    if (!wallet) throw new Error("Wallet is not connected");
    if (!account) throw new Error("Account is not connected");
    const signAndSubmitTransaction = wallet.features["xrpl:signAndSubmitTransaction"].signAndSubmitTransaction;
    return await signAndSubmitTransaction({ tx_json: transaction, account, network });
  };
  return handleSignAndSubmitTransaction;
};

const useSignTransaction = () => {
  const wallet = useWalletStore((state) => state.currentWallet);
  const account = useWalletStore((state) => state.currentAccount);
  const handleSignTransaction = async (transaction, network) => {
    if (!wallet) throw new Error("Wallet is not connected");
    if (!account) throw new Error("Account is not connected");
    const signTransaction = wallet.features["xrpl:signTransaction"].signTransaction;
    return await signTransaction({ tx_json: transaction, account, network });
  };
  return handleSignTransaction;
};

const useEvent = () => {
  const wallet = useWalletStore((state) => state.currentWallet);
  const onChange = (listener) => {
    wallet?.features["standard:events"].on("change", listener);
  };
  return { onChange };
};

const useWallet = () => {
  const wallet = useWalletStore((state) => state.currentWallet);
  const status = useWalletStore((state) => state.connectionStatus);
  const { onChange } = useEvent();
  const disconnect = useDisconnect();
  react.useEffect(() => {
    onChange(({ accounts }) => {
      if (accounts && accounts.length === 0) disconnect();
    });
  }, [disconnect, onChange]);
  if (status === "connecting") {
    return {
      wallet,
      status
    };
  }
  if (status === "connected") {
    if (!wallet) throw new Error("Wallet is connected but no wallet is set");
    return {
      wallet,
      status
    };
  }
  if (status === "disconnected") {
    return {
      wallet: null,
      status
    };
  }
  throw new Error(`Unexpected connection status: ${status}`);
};

const useWallets = () => {
  return useWalletStore((state) => state.wallets);
};

const WalletListContainer = styled.ul`
  padding: 0;
  margin: 0;
`;
const WalletItem = styled.li`
  list-style: none;
  display: flex;
`;
const WalletButton = styled.button`
  display: flex;
  width: 100%;
  justify-content: stretch;
  align-items: center;
  gap: 1rem;
  padding: 1.2rem;
  margin: 0.3rem;
`;
const WalletIcon = styled.img`
  height: 36px;
  vertical-align: middle;
`;
const WalletName = styled.span`
  vertical-align: middle;
`;
const WalletList = ({ onConnectSuccess, onConnectError }) => {
  const wallets = useWallets();
  const { connect } = useConnect();
  const handleConnect = async (wallet) => {
    try {
      await connect(wallet);
      onConnectSuccess();
    } catch (error) {
      onConnectError(error);
    }
  };
  return /* @__PURE__ */ jsxRuntime.jsx(WalletListContainer, { children: wallets.map((wallet) => /* @__PURE__ */ jsxRuntime.jsx(WalletItem, { children: /* @__PURE__ */ jsxRuntime.jsxs(WalletButton, { onClick: () => handleConnect(wallet), children: [
    /* @__PURE__ */ jsxRuntime.jsx(WalletIcon, { src: wallet.icon, alt: wallet.name }),
    /* @__PURE__ */ jsxRuntime.jsx(WalletName, { children: wallet.name })
  ] }) }, wallet.name)) });
};

const CloseButton = styled.button`
  font-family: inherit;
  padding: 0;
  border: none;
  border-radius: 100%;
  height: 25px;
  width: 25px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  color: ${colors.gray.gray11};
  position: absolute;
  top: 10px;
  right: 10px;
  background-color: inherit;
  &:hover {
    background-color: ${colors.blackA.blackA1};
  }
  &:focus {
    outline: none;
  }
`;
const overlayShow = styled.keyframes`
  from { opacity: 0; }
  to { opacity: 1; }
`;
const DialogOverlay = styled(Dialog__namespace.Overlay)`
  background-color: rgba(0, 0, 0, 0.5);

  position: fixed;
  inset: 0;
  animation: ${overlayShow} 150ms cubic-bezier(0.16, 1, 0.3, 1);
`;
const contentShow = styled.keyframes`
  from { opacity: 0; transform: translate(-50%, -48%) scale(0.96); }
  to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
`;
const DialogContent = styled(Dialog__namespace.Content)`
  background-color: white;
  border-radius: 6px;
  box-shadow: hsl(206 22% 7% / 35%) 0px 10px 38px -10px, hsl(206 22% 7% / 20%) 0px 10px 20px -15px;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 90vw;
  max-width: 450px;
  max-height: 85vh;
  padding: 25px;
  animation: ${contentShow} 150ms cubic-bezier(0.16, 1, 0.3, 1);
`;
const DialogTitle = styled(Dialog__namespace.Title)`
  margin: 0;
  text-align: center;
  font-weight: 500;
  color: ${colors.mauve.mauve11};
  font-size: 1.5em;
`;
const ConnectModal = ({ trigger }) => {
  const [open, setOpen] = react.useState(false);
  const handleConnectSuccess = () => {
    setOpen(false);
  };
  const handleConnectError = (error) => {
    console.error(error.message);
    setOpen(false);
  };
  const preventOpenAutoFocus = (e) => {
    e.preventDefault();
  };
  return /* @__PURE__ */ jsxRuntime.jsxs(Dialog__namespace.Root, { open, onOpenChange: setOpen, children: [
    /* @__PURE__ */ jsxRuntime.jsx(Dialog__namespace.Trigger, { asChild: true, children: trigger }),
    /* @__PURE__ */ jsxRuntime.jsxs(Dialog__namespace.Portal, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(DialogOverlay, {}),
      /* @__PURE__ */ jsxRuntime.jsxs(DialogContent, { "aria-describedby": void 0, onOpenAutoFocus: preventOpenAutoFocus, children: [
        /* @__PURE__ */ jsxRuntime.jsx(DialogTitle, { children: "Connect to" }),
        /* @__PURE__ */ jsxRuntime.jsx(Dialog__namespace.Description, {}),
        /* @__PURE__ */ jsxRuntime.jsx(WalletList, { onConnectSuccess: handleConnectSuccess, onConnectError: handleConnectError }),
        /* @__PURE__ */ jsxRuntime.jsx(Dialog__namespace.Close, { asChild: true, children: /* @__PURE__ */ jsxRuntime.jsx(CloseButton, { "aria-label": "Close", children: /* @__PURE__ */ jsxRuntime.jsx(reactIcons.Cross2Icon, { width: 24, height: 24 }) }) })
      ] })
    ] })
  ] });
};

const DefaultConnectButton = styled.button`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  padding: 0 15px;
  font-size: 15px;
  line-height: 1;
  font-weight: 500;
  height: 35px;
  background-color: white;
  color: ${colors.gray.gray11};
  border: 1px solid ${colors.blackA.blackA7};
  &:hover {
    border: 1px solid ${colors.blackA.blackA7};
    background-color: ${colors.blackA.blackA1};
  }
  &:focus {
    outline: none;
  }
`;
const ConnectButton = (props) => {
  return /* @__PURE__ */ jsxRuntime.jsx(ConnectModal, { trigger: /* @__PURE__ */ jsxRuntime.jsx(DefaultConnectButton, { ...props, children: "Connect Wallet" }) });
};

const useAutoConnect = () => {
  const { connect } = useConnect();
  const lastConnectedAccountAddress = useWalletStore((state) => state.lastConnectedAccountAddress);
  const lastConnectedWalletName = useWalletStore((state) => state.lastConnectedWalletName);
  const { status } = useWallet();
  react.useEffect(() => {
    if (status !== "disconnected" || !lastConnectedAccountAddress || !lastConnectedWalletName) {
      return;
    }
    const lastConnectedWallet = app.getRegisterdXRPLWallets().find((wallet) => wallet.name === lastConnectedWalletName);
    if (!lastConnectedWallet) return;
    setTimeout(() => {
      connect(lastConnectedWallet, { silent: true });
    }, 1e3);
  }, []);
};

function createWalletStore({ wallets, storage, storageKey, autoConnectEnabled }) {
  return zustand.createStore()(
    middleware.persist(
      (set, get) => ({
        autoConnectEnabled,
        wallets,
        accounts: [],
        currentWallet: null,
        currentAccount: null,
        lastConnectedAccountAddress: null,
        lastConnectedWalletName: null,
        connectionStatus: "disconnected",
        setConnectionStatus(connectionStatus) {
          set(() => ({
            connectionStatus
          }));
        },
        setWallet(wallet, connectedAccounts, selectedAccount) {
          set(() => ({
            accounts: connectedAccounts,
            currentWallet: wallet,
            currentAccount: selectedAccount,
            lastConnectedWalletName: wallet.name,
            lastConnectedAccountAddress: selectedAccount?.address,
            connectionStatus: "connected"
          }));
        },
        setWalletDisconnected() {
          set(() => ({
            accounts: [],
            currentWallet: null,
            currentAccount: null,
            lastConnectedWalletName: null,
            lastConnectedAccountAddress: null,
            connectionStatus: "disconnected"
          }));
        },
        setAccountChanged(selectedAccount) {
          set(() => ({
            currentAccount: selectedAccount,
            lastConnectedAccountAddress: selectedAccount.address
          }));
        },
        setWalletRegistered(updatedWallets) {
          set(() => ({ wallets: updatedWallets }));
        },
        setWalletUnregistered(updatedWallets, unregisteredWallet) {
          if (unregisteredWallet === get().currentWallet) {
            set(() => ({
              wallets: updatedWallets,
              accounts: [],
              currentWallet: null,
              currentAccount: null,
              lastConnectedWalletName: null,
              lastConnectedAccountAddress: null,
              connectionStatus: "disconnected"
            }));
          } else {
            set(() => ({ wallets: updatedWallets }));
          }
        },
        updateWalletAccounts(accounts) {
          const currentAccount = get().currentAccount;
          set(() => ({
            accounts,
            currentAccount: currentAccount && accounts.find(({ address }) => address === currentAccount.address) || accounts[0]
          }));
        }
      }),
      {
        name: storageKey,
        storage: middleware.createJSONStorage(() => storage || localStorage),
        partialize: ({ lastConnectedWalletName, lastConnectedAccountAddress }) => ({
          lastConnectedWalletName,
          lastConnectedAccountAddress
        })
      }
    )
  );
}

const isSSR = typeof window === "undefined";
function WalletProvider({ autoConnect = true, registerWallets, children }) {
  if (!isSSR && registerWallets)
    registerWallets.filter((wallet) => !app.getRegisterdXRPLWallets().find((rw) => rw.name === wallet.name)).forEach((wallet) => {
      app.registerWallet(wallet);
    });
  const storeRef = react.useRef(
    !isSSR ? createWalletStore({
      autoConnectEnabled: autoConnect,
      wallets: app.getRegisterdXRPLWallets(),
      storageKey: "@xrpl-wallet-standard/app/react"
    }) : null
  );
  return /* @__PURE__ */ jsxRuntime.jsx(WalletContext.Provider, { value: storeRef.current, children: autoConnect ? /* @__PURE__ */ jsxRuntime.jsx(WalletAutoConnect, { children }) : children });
}
function WalletAutoConnect({ children }) {
  useAutoConnect();
  return children;
}

exports.ConnectButton = ConnectButton;
exports.WalletProvider = WalletProvider;
exports.useAccount = useAccount;
exports.useAccounts = useAccounts;
exports.useConnect = useConnect;
exports.useConnectionStatus = useConnectionStatus;
exports.useDisconnect = useDisconnect;
exports.useSignAndSubmitTransaction = useSignAndSubmitTransaction;
exports.useSignTransaction = useSignTransaction;
exports.useWallet = useWallet;
exports.useWallets = useWallets;
