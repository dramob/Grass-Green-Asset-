"use client";
import { jsx, jsxs } from 'react/jsx-runtime';
import { gray, blackA, mauve } from '@radix-ui/colors';
import styled, { keyframes } from 'styled-components';
import * as Dialog from '@radix-ui/react-dialog';
import { Cross2Icon } from '@radix-ui/react-icons';
import { createContext, useContext, useEffect, useState, useRef } from 'react';
import { useStore, createStore } from 'zustand';
import { isWalletWithRequiredFeatureSet, getRegisterdXRPLWallets, registerWallet } from '@xrpl-wallet-standard/app';
import { persist, createJSONStorage } from 'zustand/middleware';

const WalletContext = createContext(null);

function useWalletStore(selector) {
  const store = useContext(WalletContext);
  if (!store)
    throw new Error(
      "useWalletStore must be used within a WalletProvider. Did you forget to wrap your component in a WalletProvider?"
    );
  return useStore(store, selector);
}

const useAccount = () => {
  return useWalletStore((state) => state.currentAccount);
};

const useAccounts = () => {
  return useWalletStore((state) => state.accounts);
};

const useConnect = () => {
  const connectionStatus = useWalletStore((state) => state.connectionStatus);
  const setConnectionStatus = useWalletStore((state) => state.setConnectionStatus);
  const setWallet = useWalletStore((state) => state.setWallet);
  const handleConnect = async (wallet, input) => {
    setConnectionStatus("connecting");
    try {
      const { accounts } = await wallet.features["standard:connect"].connect(input);
      if (accounts.length === 0) {
        throw new Error("No accounts found");
      }
      const account = accounts[0];
      setWallet(wallet, accounts, account);
      setConnectionStatus("connected");
    } catch (e) {
      setConnectionStatus("disconnected");
      throw e;
    }
  };
  return { connect: handleConnect, status: connectionStatus };
};

const useConnectionStatus = () => {
  const status = useWalletStore((state) => state.connectionStatus);
  return status;
};

const useDisconnect = () => {
  const wallet = useWalletStore((state) => state.currentWallet);
  const setWalletDisconnected = useWalletStore((state) => state.setWalletDisconnected);
  const handleDisconnect = async () => {
    if (!wallet) throw new Error("Wallet is not connected");
    if (isWalletWithRequiredFeatureSet(wallet, ["standard:disconnect"]))
      try {
        await wallet.features["standard:disconnect"].disconnect();
      } catch (e) {
        console.error(e);
      }
    setWalletDisconnected();
  };
  return handleDisconnect;
};

const useSignAndSubmitTransaction = () => {
  const wallet = useWalletStore((state) => state.currentWallet);
  const account = useWalletStore((state) => state.currentAccount);
  const handleSignAndSubmitTransaction = async (transaction, network) => {
    if (!wallet) throw new Error("Wallet is not connected");
    if (!account) throw new Error("Account is not connected");
    const signAndSubmitTransaction = wallet.features["xrpl:signAndSubmitTransaction"].signAndSubmitTransaction;
    return await signAndSubmitTransaction({ tx_json: transaction, account, network });
  };
  return handleSignAndSubmitTransaction;
};

const useSignTransaction = () => {
  const wallet = useWalletStore((state) => state.currentWallet);
  const account = useWalletStore((state) => state.currentAccount);
  const handleSignTransaction = async (transaction, network) => {
    if (!wallet) throw new Error("Wallet is not connected");
    if (!account) throw new Error("Account is not connected");
    const signTransaction = wallet.features["xrpl:signTransaction"].signTransaction;
    return await signTransaction({ tx_json: transaction, account, network });
  };
  return handleSignTransaction;
};

const useEvent = () => {
  const wallet = useWalletStore((state) => state.currentWallet);
  const onChange = (listener) => {
    wallet?.features["standard:events"].on("change", listener);
  };
  return { onChange };
};

const useWallet = () => {
  const wallet = useWalletStore((state) => state.currentWallet);
  const status = useWalletStore((state) => state.connectionStatus);
  const { onChange } = useEvent();
  const disconnect = useDisconnect();
  useEffect(() => {
    onChange(({ accounts }) => {
      if (accounts && accounts.length === 0) disconnect();
    });
  }, [disconnect, onChange]);
  if (status === "connecting") {
    return {
      wallet,
      status
    };
  }
  if (status === "connected") {
    if (!wallet) throw new Error("Wallet is connected but no wallet is set");
    return {
      wallet,
      status
    };
  }
  if (status === "disconnected") {
    return {
      wallet: null,
      status
    };
  }
  throw new Error(`Unexpected connection status: ${status}`);
};

const useWallets = () => {
  return useWalletStore((state) => state.wallets);
};

const WalletListContainer = styled.ul`
  padding: 0;
  margin: 0;
`;
const WalletItem = styled.li`
  list-style: none;
  display: flex;
`;
const WalletButton = styled.button`
  display: flex;
  width: 100%;
  justify-content: stretch;
  align-items: center;
  gap: 1rem;
  padding: 1.2rem;
  margin: 0.3rem;
`;
const WalletIcon = styled.img`
  height: 36px;
  vertical-align: middle;
`;
const WalletName = styled.span`
  vertical-align: middle;
`;
const WalletList = ({ onConnectSuccess, onConnectError }) => {
  const wallets = useWallets();
  const { connect } = useConnect();
  const handleConnect = async (wallet) => {
    try {
      await connect(wallet);
      onConnectSuccess();
    } catch (error) {
      onConnectError(error);
    }
  };
  return /* @__PURE__ */ jsx(WalletListContainer, { children: wallets.map((wallet) => /* @__PURE__ */ jsx(WalletItem, { children: /* @__PURE__ */ jsxs(WalletButton, { onClick: () => handleConnect(wallet), children: [
    /* @__PURE__ */ jsx(WalletIcon, { src: wallet.icon, alt: wallet.name }),
    /* @__PURE__ */ jsx(WalletName, { children: wallet.name })
  ] }) }, wallet.name)) });
};

const CloseButton = styled.button`
  font-family: inherit;
  padding: 0;
  border: none;
  border-radius: 100%;
  height: 25px;
  width: 25px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  color: ${gray.gray11};
  position: absolute;
  top: 10px;
  right: 10px;
  background-color: inherit;
  &:hover {
    background-color: ${blackA.blackA1};
  }
  &:focus {
    outline: none;
  }
`;
const overlayShow = keyframes`
  from { opacity: 0; }
  to { opacity: 1; }
`;
const DialogOverlay = styled(Dialog.Overlay)`
  background-color: rgba(0, 0, 0, 0.5);

  position: fixed;
  inset: 0;
  animation: ${overlayShow} 150ms cubic-bezier(0.16, 1, 0.3, 1);
`;
const contentShow = keyframes`
  from { opacity: 0; transform: translate(-50%, -48%) scale(0.96); }
  to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
`;
const DialogContent = styled(Dialog.Content)`
  background-color: white;
  border-radius: 6px;
  box-shadow: hsl(206 22% 7% / 35%) 0px 10px 38px -10px, hsl(206 22% 7% / 20%) 0px 10px 20px -15px;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 90vw;
  max-width: 450px;
  max-height: 85vh;
  padding: 25px;
  animation: ${contentShow} 150ms cubic-bezier(0.16, 1, 0.3, 1);
`;
const DialogTitle = styled(Dialog.Title)`
  margin: 0;
  text-align: center;
  font-weight: 500;
  color: ${mauve.mauve11};
  font-size: 1.5em;
`;
const ConnectModal = ({ trigger }) => {
  const [open, setOpen] = useState(false);
  const handleConnectSuccess = () => {
    setOpen(false);
  };
  const handleConnectError = (error) => {
    console.error(error.message);
    setOpen(false);
  };
  const preventOpenAutoFocus = (e) => {
    e.preventDefault();
  };
  return /* @__PURE__ */ jsxs(Dialog.Root, { open, onOpenChange: setOpen, children: [
    /* @__PURE__ */ jsx(Dialog.Trigger, { asChild: true, children: trigger }),
    /* @__PURE__ */ jsxs(Dialog.Portal, { children: [
      /* @__PURE__ */ jsx(DialogOverlay, {}),
      /* @__PURE__ */ jsxs(DialogContent, { "aria-describedby": void 0, onOpenAutoFocus: preventOpenAutoFocus, children: [
        /* @__PURE__ */ jsx(DialogTitle, { children: "Connect to" }),
        /* @__PURE__ */ jsx(Dialog.Description, {}),
        /* @__PURE__ */ jsx(WalletList, { onConnectSuccess: handleConnectSuccess, onConnectError: handleConnectError }),
        /* @__PURE__ */ jsx(Dialog.Close, { asChild: true, children: /* @__PURE__ */ jsx(CloseButton, { "aria-label": "Close", children: /* @__PURE__ */ jsx(Cross2Icon, { width: 24, height: 24 }) }) })
      ] })
    ] })
  ] });
};

const DefaultConnectButton = styled.button`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  padding: 0 15px;
  font-size: 15px;
  line-height: 1;
  font-weight: 500;
  height: 35px;
  background-color: white;
  color: ${gray.gray11};
  border: 1px solid ${blackA.blackA7};
  &:hover {
    border: 1px solid ${blackA.blackA7};
    background-color: ${blackA.blackA1};
  }
  &:focus {
    outline: none;
  }
`;
const ConnectButton = (props) => {
  return /* @__PURE__ */ jsx(ConnectModal, { trigger: /* @__PURE__ */ jsx(DefaultConnectButton, { ...props, children: "Connect Wallet" }) });
};

const useAutoConnect = () => {
  const { connect } = useConnect();
  const lastConnectedAccountAddress = useWalletStore((state) => state.lastConnectedAccountAddress);
  const lastConnectedWalletName = useWalletStore((state) => state.lastConnectedWalletName);
  const { status } = useWallet();
  useEffect(() => {
    if (status !== "disconnected" || !lastConnectedAccountAddress || !lastConnectedWalletName) {
      return;
    }
    const lastConnectedWallet = getRegisterdXRPLWallets().find((wallet) => wallet.name === lastConnectedWalletName);
    if (!lastConnectedWallet) return;
    setTimeout(() => {
      connect(lastConnectedWallet, { silent: true });
    }, 1e3);
  }, []);
};

function createWalletStore({ wallets, storage, storageKey, autoConnectEnabled }) {
  return createStore()(
    persist(
      (set, get) => ({
        autoConnectEnabled,
        wallets,
        accounts: [],
        currentWallet: null,
        currentAccount: null,
        lastConnectedAccountAddress: null,
        lastConnectedWalletName: null,
        connectionStatus: "disconnected",
        setConnectionStatus(connectionStatus) {
          set(() => ({
            connectionStatus
          }));
        },
        setWallet(wallet, connectedAccounts, selectedAccount) {
          set(() => ({
            accounts: connectedAccounts,
            currentWallet: wallet,
            currentAccount: selectedAccount,
            lastConnectedWalletName: wallet.name,
            lastConnectedAccountAddress: selectedAccount?.address,
            connectionStatus: "connected"
          }));
        },
        setWalletDisconnected() {
          set(() => ({
            accounts: [],
            currentWallet: null,
            currentAccount: null,
            lastConnectedWalletName: null,
            lastConnectedAccountAddress: null,
            connectionStatus: "disconnected"
          }));
        },
        setAccountChanged(selectedAccount) {
          set(() => ({
            currentAccount: selectedAccount,
            lastConnectedAccountAddress: selectedAccount.address
          }));
        },
        setWalletRegistered(updatedWallets) {
          set(() => ({ wallets: updatedWallets }));
        },
        setWalletUnregistered(updatedWallets, unregisteredWallet) {
          if (unregisteredWallet === get().currentWallet) {
            set(() => ({
              wallets: updatedWallets,
              accounts: [],
              currentWallet: null,
              currentAccount: null,
              lastConnectedWalletName: null,
              lastConnectedAccountAddress: null,
              connectionStatus: "disconnected"
            }));
          } else {
            set(() => ({ wallets: updatedWallets }));
          }
        },
        updateWalletAccounts(accounts) {
          const currentAccount = get().currentAccount;
          set(() => ({
            accounts,
            currentAccount: currentAccount && accounts.find(({ address }) => address === currentAccount.address) || accounts[0]
          }));
        }
      }),
      {
        name: storageKey,
        storage: createJSONStorage(() => storage || localStorage),
        partialize: ({ lastConnectedWalletName, lastConnectedAccountAddress }) => ({
          lastConnectedWalletName,
          lastConnectedAccountAddress
        })
      }
    )
  );
}

const isSSR = typeof window === "undefined";
function WalletProvider({ autoConnect = true, registerWallets, children }) {
  if (!isSSR && registerWallets)
    registerWallets.filter((wallet) => !getRegisterdXRPLWallets().find((rw) => rw.name === wallet.name)).forEach((wallet) => {
      registerWallet(wallet);
    });
  const storeRef = useRef(
    !isSSR ? createWalletStore({
      autoConnectEnabled: autoConnect,
      wallets: getRegisterdXRPLWallets(),
      storageKey: "@xrpl-wallet-standard/app/react"
    }) : null
  );
  return /* @__PURE__ */ jsx(WalletContext.Provider, { value: storeRef.current, children: autoConnect ? /* @__PURE__ */ jsx(WalletAutoConnect, { children }) : children });
}
function WalletAutoConnect({ children }) {
  useAutoConnect();
  return children;
}

export { ConnectButton, WalletProvider, useAccount, useAccounts, useConnect, useConnectionStatus, useDisconnect, useSignAndSubmitTransaction, useSignTransaction, useWallet, useWallets };
