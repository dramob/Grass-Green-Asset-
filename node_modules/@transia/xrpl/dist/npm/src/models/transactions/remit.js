"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateRemit = void 0;
const errors_1 = require("../../errors");
const utils_1 = require("../utils");
const common_1 = require("./common");
const MAX_URI_LENGTH = 512;
const DIGEST_LENGTH = 64;
const MAX_ARRAY_LENGTH = 32;
const MAX_BLOB_LENGTH = 1024;
function validateRemit(tx) {
    (0, common_1.validateBaseTransaction)(tx);
    if (tx.Amounts !== undefined) {
        checkAmounts(tx);
    }
    if (tx.URITokenIDs !== undefined) {
        checkURITokenIDs(tx);
    }
    if (tx.Destination === tx.Account) {
        throw new errors_1.ValidationError('Remit: Destination must not be equal to the account');
    }
    if (tx.DestinationTag != null && typeof tx.DestinationTag !== 'number') {
        throw new errors_1.ValidationError('Remit: DestinationTag must be a number');
    }
    if (tx.Inform === tx.Account || tx.Inform === tx.Destination) {
        throw new errors_1.ValidationError('Remit: Inform must not be equal to the account or destination');
    }
    if (tx.MintURIToken !== undefined) {
        checkMintURIToken(tx);
    }
    if (tx.Blob !== undefined && typeof tx.Blob !== 'string') {
        throw new errors_1.ValidationError('Remit: Blob must be a string');
    }
    if (tx.Blob !== undefined && typeof tx.Blob === 'string') {
        if (!(0, utils_1.isHex)(tx.Blob)) {
            throw new errors_1.ValidationError('Remit: Blob must be a hex string');
        }
        if (tx.Blob.length > MAX_BLOB_LENGTH) {
            throw new errors_1.ValidationError('Remit: max size Blob');
        }
    }
}
exports.validateRemit = validateRemit;
function checkAmounts(tx) {
    if (!Array.isArray(tx.Amounts)) {
        throw new errors_1.ValidationError('Remit: Amounts must be an array');
    }
    if (tx.Amounts.length < 1) {
        throw new errors_1.ValidationError('Remit: empty field Amounts');
    }
    if (tx.Amounts.length > MAX_ARRAY_LENGTH) {
        throw new errors_1.ValidationError('Remit: max field Amounts');
    }
    const seen = new Set();
    let seenXrp = false;
    for (const amount of tx.Amounts) {
        if (amount.AmountEntry === undefined ||
            typeof amount.AmountEntry !== 'object') {
            throw new errors_1.ValidationError('Remit: invalid Amounts.AmountEntry');
        }
        if (typeof amount.AmountEntry.Amount === 'string') {
            if (seenXrp) {
                throw new errors_1.ValidationError('Remit: Duplicate Native amounts are not allowed');
            }
            seenXrp = true;
        }
        else {
            const amountKey = `${amount.AmountEntry.Amount.currency}:${amount.AmountEntry.Amount.issuer}`;
            if (seen.has(amountKey)) {
                throw new errors_1.ValidationError('Remit: Duplicate amounts are not allowed');
            }
            seen.add(amountKey);
        }
    }
}
function checkURITokenIDs(tx) {
    if (!Array.isArray(tx.URITokenIDs)) {
        throw new errors_1.ValidationError('Remit: invalid field URITokenIDs');
    }
    if (tx.URITokenIDs.length < 1) {
        throw new errors_1.ValidationError('Remit: empty field URITokenIDs');
    }
    if (tx.URITokenIDs.length > MAX_ARRAY_LENGTH) {
        throw new errors_1.ValidationError('Remit: max field URITokenIDs');
    }
    const seen = new Set();
    for (const token of tx.URITokenIDs) {
        if (typeof token !== 'string' || !(0, utils_1.isHex)(token)) {
            throw new errors_1.ValidationError('Remit: URITokenID must be a hex string');
        }
        if (token.length !== DIGEST_LENGTH) {
            throw new errors_1.ValidationError(`Remit: URITokenID must be exactly ${DIGEST_LENGTH} characters`);
        }
        if (seen.has(token)) {
            throw new errors_1.ValidationError('Remit: Duplicate URITokens are not allowed');
        }
        seen.add(token);
    }
}
function checkMintURIToken(tx) {
    function isRecord(value) {
        return value !== null && typeof value === 'object';
    }
    if (!isRecord(tx.MintURIToken)) {
        throw new errors_1.ValidationError('Remit: invalid MintURIToken');
    }
    if (tx.MintURIToken.URI === undefined) {
        throw new errors_1.ValidationError('Remit: missing field MintURIToken.URI');
    }
    if (typeof tx.MintURIToken.URI !== 'string' || !(0, utils_1.isHex)(tx.MintURIToken.URI)) {
        throw new errors_1.ValidationError('Remit: MintURIToken.URI must be a hex string');
    }
    if (tx.MintURIToken.URI.length > MAX_URI_LENGTH) {
        throw new errors_1.ValidationError(`Remit: URI must be less than ${MAX_URI_LENGTH} characters`);
    }
    if (tx.MintURIToken.Digest !== undefined &&
        typeof tx.MintURIToken.Digest !== 'string') {
        throw new errors_1.ValidationError(`Remit: MintURIToken.Digest must be a string`);
    }
    if (tx.MintURIToken.Digest !== undefined &&
        !(0, utils_1.isHex)(tx.MintURIToken.Digest) &&
        tx.MintURIToken.Digest.length !== DIGEST_LENGTH) {
        throw new errors_1.ValidationError(`Remit: Digest must be exactly ${DIGEST_LENGTH} characters`);
    }
}
//# sourceMappingURL=remit.js.map